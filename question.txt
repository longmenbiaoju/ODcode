
03 【跳格子】

地上共有N个格子，你需要跳完地上所有的格子，但是格子间是有强依赖关系的，跳完前一个格子后，后续的格子才会被开启，格子间的依赖关系由多组steps数组给出，steps[0]表示前一个格子，steps[1]表示steps[0]可以开启的格子:

比如[0,1]表示从跳完第0个格子以后第1个格子就开启了，比如[2,1]，[2,3]表示跳完第2个格子后第1个格子和第3个格子就被开启了。

请你计算是否能由给出的steps数组跳完所有的格子，如果可以输出yes，否则输出no。

说明：

1.你可以从一个格子跳到任意一个开启的格子

2.没有前置依赖条件的格子默认就是开启的

3.如果总数是N，则所有的格子编号为[0,1,2,3…N-1]连续的数组

输入描述:

输入一个整数N表示总共有多少个格子，接着输入多组二维数组steps表示所有格子之间的依赖关系。

输出描述:

如果能按照steps给定的依赖顺序跳完所有的格子输出yes，

否则输出no。

示例1   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

3

0 1

0 2

输出

yes

说明

总共有三个格子[0,1,2]，跳完0个格子后第1个格子就开启了，跳到第0个格子后第2个格子也被开启了，按照0->1->2或者0->2->1的顺序都可以跳完所有的格子

示例2   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

2

1 0

0 1

输出

no

说明

总共有2个格子，第1个格子可以开启第0格子，但是第1个格子又需要第0个格子才能开启，相互依赖，因此无法完成

示例3   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

6

0 1

0 2

0 3

0 4

0 5

输出

yes

说明

总共有6个格子，第0个格子可以开启第1,2,3,4,5个格子，所以跳完第0个格子之后其他格子都被开启了，之后按任何顺序可以跳完剩余的格子

示例4   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

5

4 3

0 4

2 1

3 2

输出

yes

说明

跳完第0个格子可以开启格子4，跳完格子4可以开启格子3，跳完格子3可以开启格子2，跳完格子2可以开启格子1，按照0->4->3->2->1这样就跳完所有的格子

示例5   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

4

1 2

1 0

输出

yes

说明

总共4个格子[0,1,2,3]，格子1和格子3没有前置条件所以默认开启，格子1可以开启格子0和格子2，所以跳到格子1之后就可以开启所有的格子，因此可以跳完所有格子。



04【二叉树中序遍历】

根据给定的二叉树结构描述字符串，输出该二叉树按照中序遍历结果字符串。中序遍历顺序为：左子树，根结点，右子树。

输入描述

由大小写字母、左右大括号、逗号组成的字符串:字母代表一个节点值，左右括号内包含该节点的子节点。

左右子节点使用逗号分隔，逗号前为空则表示左子节点为空，没有逗号则表示右子节点为空。

二叉树节点数最大不超过100。

注:输入字符串格式是正确的，无需考虑格式错误的情况。

输出描述

输出一个字符串为二叉树中序遍历各节点值的拼接结果。

示例 1   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

a{b{d,e{g,h{,I}}},c{f}}

输出

dbgehiafc

05【出错的或电路】

某生产门电路的厂商发现某一批次的或门电路不稳定，具体现象为计算两个二进制数的或操作时，第一个二进制数中某两个比特位会出现交换，
交换的比特位置是随机的，但只交换这两个位，其他位不变。

很明显，这个交换可能会影响最终的或结果，也可能不会有影响。

为了评估影响和定位出错的根因，工程师需要研究在各种交换的可能下，最终的或结果发生改变的情况有多少种。

输入描述:

第一行有一个正整数N;其中1≤N≤1000000。
第二行有一个长为N的二进制数，表示与电路的第一个输入数，即会发生比特交换的输入数。
第三行有一个长为N的二进制数，表示与电路的第二个输入数。注意第二个输入数不会发生比特交换。

输出描述:

输出只有一个整数，表示会影响或结果的交换方案个数。

示例1   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

3
010
110

输出

1

说明

原本010和110的或结果是110，但第一个输入数可能会发生如下三种交换：

1.交换第1个比特和第2个比特，第一个输入数变为100，计算结果为110，计算结果不变
2.交换第1个比特和第3个比特，第一个输入数变为010，计算结果为110，计算结果不变
3.交换第2个比特和第3个比特，第一个输入数变为001，计算结果为111，计算结果改变
故只有一种交换会改变计算结果。



06【图像物体的边界】

给定一个二维数组M行N列，二维数组里的数字代表图片的像素，为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。

像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界，相邻需要考虑8个方向（上，下，左，右，左上，左下，右上，右下）。

其他约束

地图规格约束为：

0<M<100
0<N<100

1）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（4,4）、（4,5）、（5,4）为边界，另（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）相邻，为1个边界，（4,4）、（4,5）、（5,4）相邻，为1个边界，所以下图边界个数为2。

 

2）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（3,3）、（3,4）、（3,5）、（4,3）、（4,5）、（5,3）、（5,4）、（5,5）为边界，另这些边界相邻，所以下图边界个数为1。

 

注：（2,2）、（3,3）相邻。

输入描述

第一行，行数M，列数N

第二行开始，是M行N列的像素的二维数组，仅包含像素1和5

输出描述

像素1代表的物体的边界个数。

如果没有边界输出0（比如只存在像素1，或者只存在像素5）。

示例1   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

6 6
1 1 1 1 1 1
1 5 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 5

输出

2

说明

参考题目描述部分

示例2   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

6 6
1 1 1 1 1 1
1 5 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 5 1
1 1 1 1 1 1

输出

1



